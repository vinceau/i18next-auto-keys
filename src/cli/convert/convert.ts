import fs from "fs";
import path from "path";
import { sync as globSync } from "glob";
import { loadGettextParser } from "../loadGettextParser";
import { stableHash, loadConfig } from "@/index";

const MAX_LENGTH = 60;

export type ConvertPoOptions = {
  input: string;
  output: string;
  topLevelKey?: string;
  indent?: number;
  verbose?: boolean;
};

/**
 * Converts .po files to i18next compatible JSON format.
 *
 * The .po file should have been generated by the i18next-auto-keys CLI
 * where msgctxt contains the i18next key path and msgid contains the source text.
 */
export async function convertPoToJson(options: ConvertPoOptions): Promise<void> {
  const { input, output, topLevelKey, verbose, indent = 2 } = options;

  // Load config to get hash length
  const { config } = loadConfig();

  console.log(`üìñ Converting .po file to i18next JSON: ${input}`);
  console.log(`üìÅ Output: ${output}`);

  // Check if input exists
  if (!fs.existsSync(input)) {
    throw new Error(`Input file not found: ${input}`);
  }

  // Load gettext parser
  const parser = await loadGettextParser();

  // Read and parse .po file
  const poBuffer = fs.readFileSync(input);
  const catalog = parser.po.parse(poBuffer);

  // Extract translations
  const translations: Record<string, string> = {};
  let translationCount = 0;
  let untranslatedCount = 0;

  // Note: gettext-parser structure is translations[msgctxt][msgid] = entryData
  for (const [contextKey, contextEntries] of Object.entries(catalog.translations)) {
    for (const [msgid, entryData] of Object.entries(contextEntries as any)) {
      if (msgid === "" || !entryData) continue; // Skip header entry

      // We don't care about plural forms, so we take the first msgstr
      const msgstr: string = (entryData as any).msgstr[0] || "";
      const msgctxt: string | undefined = (entryData as any).msgctxt;

      // Skip untranslated entries
      if (!msgstr) {
        untranslatedCount++;
        if (verbose) {
          const content = msgctxt ? `[${msgctxt}] ${msgid}` : msgid;
          const identifier = content.length > MAX_LENGTH ? content.slice(0, MAX_LENGTH) + "..." : content;
          console.warn(`‚ö†Ô∏è  Skipping untranslated key: ${identifier}`);
        }
        continue;
      }

      // Generate hash from msgid + msgctxt (translation context)
      const key = stableHash(msgid, { context: msgctxt, hashLength: config.hashLength });

      // Use the generated hash as a flat key (no nesting)
      translations[key] = msgstr;
      translationCount++;
    }
  }

  console.log(`üîë Processed ${translationCount} translations. Skipped ${untranslatedCount} untranslated entries.`);

  // Sort translations by key for consistent output (matches emit plugin behavior)
  const sortedTranslations: Record<string, string> = {};
  Object.keys(translations)
    .sort()
    .forEach((key) => {
      sortedTranslations[key] = translations[key];
    });

  // Wrap under topLevelKey if specified (matches emit plugin behavior)
  let output_data: any = sortedTranslations;
  if (topLevelKey) {
    output_data = { [topLevelKey]: sortedTranslations };
  }

  // Ensure output directory exists
  const outputDir = path.dirname(output);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write JSON file
  const jsonContent = JSON.stringify(output_data, null, indent);
  fs.writeFileSync(output, jsonContent, "utf8");

  console.log(`‚úÖ i18next JSON file generated: ${output}`);
}

/**
 * Converts multiple .po files to JSON format.
 * Useful for batch processing multiple language files.
 */
export async function convertMultiplePoToJson(options: {
  pattern: string;
  outputDir: string;
  topLevelKey?: string;
  indent?: number;
  verbose?: boolean;
}): Promise<void> {
  const { pattern, outputDir, topLevelKey, indent = 2, verbose } = options;

  console.log(`üîç Scanning for .po files using pattern: ${pattern}`);

  // Find .po files
  const poFiles = globSync(pattern, { absolute: true });
  console.log(`üìÅ Found ${poFiles.length} .po files`);

  if (poFiles.length === 0) {
    console.warn("‚ö†Ô∏è  No .po files found matching the pattern");
    return;
  }

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Process each .po file
  for (const poFile of poFiles) {
    const baseName = path.basename(poFile, ".po");
    const jsonFile = path.join(outputDir, `${baseName}.json`);

    try {
      await convertPoToJson({
        input: poFile,
        output: jsonFile,
        topLevelKey,
        indent,
        verbose,
      });
    } catch (error) {
      console.error(`‚ùå Error converting ${poFile}:`, error);
    }
  }

  console.log(`‚úÖ Batch conversion completed. Output directory: ${outputDir}`);
}
