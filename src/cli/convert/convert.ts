import fs from "fs";
import path from "path";
import { sync as globSync } from "glob";
import { loadGettextParser } from "../loadGettextParser";

export type ConvertPoOptions = {
  input: string;
  output: string;
  topLevelKey?: string;
  indent?: number;
};

/**
 * Converts .po files to i18next compatible JSON format.
 *
 * The .po file should have been generated by the i18next-auto-keys CLI
 * where msgctxt contains the i18next key path and msgid contains the source text.
 */
export async function convertPoToJson(options: ConvertPoOptions): Promise<void> {
  const { input, output, topLevelKey, indent = 2 } = options;

  console.log(`üìñ Converting .po file to i18next JSON: ${input}`);
  console.log(`üìÅ Output: ${output}`);

  // Check if input exists
  if (!fs.existsSync(input)) {
    throw new Error(`Input file not found: ${input}`);
  }

  // Load gettext parser
  const parser = await loadGettextParser();
  if (!parser?.po?.parse) {
    throw new Error("gettext-parser is required to parse .po files. Install it with: npm install gettext-parser");
  }

  // Read and parse .po file
  const poBuffer = fs.readFileSync(input);
  const catalog = parser.po.parse(poBuffer);

  // Extract translations
  const translations: Record<string, any> = {};
  let translationCount = 0;

  // Process translations (skip the header entry which has empty msgid)
  const translationEntries = catalog.translations?.[""] || {};
  for (const [msgid, entry] of Object.entries(translationEntries)) {
    if (msgid === "" || !entry) continue; // Skip header entry

    const entryData = entry as any;
    const msgstr = entryData.msgstr?.[0];
    const msgctxt = entryData.msgctxt;

    // Skip untranslated entries
    if (!msgstr || msgstr === "") {
      console.warn(`‚ö†Ô∏è  Skipping untranslated key: ${msgctxt || msgid}`);
      continue;
    }

    // Use msgctxt (i18next key path) as the key, fallback to msgid
    const key = msgctxt || msgid;

    // For hexadecimal hash keys (like "a1b2c3d4e5"), use them as direct keys
    // For other keys, convert dot-notation to nested objects
    if (isHexadecimalHash(key)) {
      translations[key] = msgstr;
    } else {
      // Convert dot-notation key path to nested object
      setNestedValue(translations, key, msgstr);
    }
    translationCount++;
  }

  console.log(`üîë Processed ${translationCount} translations`);

  // Wrap under topLevelKey if specified (matches emit plugin behavior)
  let output_data = translations;
  if (topLevelKey) {
    output_data = { [topLevelKey]: translations };
  }

  // Ensure output directory exists
  const outputDir = path.dirname(output);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write JSON file
  const jsonContent = JSON.stringify(output_data, null, indent);
  fs.writeFileSync(output, jsonContent, "utf8");

  console.log(`‚úÖ i18next JSON file generated: ${output}`);
}

/**
 * Converts multiple .po files to JSON format.
 * Useful for batch processing multiple language files.
 */
export async function convertMultiplePoToJson(options: {
  pattern: string;
  outputDir: string;
  topLevelKey?: string;
  indent?: number;
}): Promise<void> {
  const { pattern, outputDir, topLevelKey, indent = 2 } = options;

  console.log(`üîç Scanning for .po files using pattern: ${pattern}`);

  // Find .po files
  const poFiles = globSync(pattern, { absolute: true });
  console.log(`üìÅ Found ${poFiles.length} .po files`);

  if (poFiles.length === 0) {
    console.warn("‚ö†Ô∏è  No .po files found matching the pattern");
    return;
  }

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Process each .po file
  for (const poFile of poFiles) {
    const baseName = path.basename(poFile, ".po");
    const jsonFile = path.join(outputDir, `${baseName}.json`);

    try {
      await convertPoToJson({
        input: poFile,
        output: jsonFile,
        topLevelKey,
        indent,
      });
    } catch (error) {
      console.error(`‚ùå Error converting ${poFile}:`, error);
    }
  }

  console.log(`‚úÖ Batch conversion completed. Output directory: ${outputDir}`);
}

/**
 * Helper function to check if a key is a hexadecimal hash (like the ones generated by i18next-auto-keys).
 * Hexadecimal hashes are typically 10+ characters of lowercase letters and digits.
 */
function isHexadecimalHash(key: string): boolean {
  return /^[a-f0-9]{10,}$/.test(key);
}

/**
 * Helper function to set nested object values using dot notation.
 * Example: setNestedValue(obj, "a.b.c", "value") sets obj.a.b.c = "value"
 */
function setNestedValue(obj: Record<string, any>, keyPath: string, value: any): void {
  const keys = keyPath.split(".");
  let current = obj;

  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    if (!(key in current) || typeof current[key] !== "object" || Array.isArray(current[key])) {
      current[key] = {};
    }
    current = current[key];
  }

  const lastKey = keys[keys.length - 1];
  current[lastKey] = value;
}
